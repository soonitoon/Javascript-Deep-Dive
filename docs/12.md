# 12장: 함수

## 12.1 함수란?

- 프로그래밍 언어에서의 함수: **일련의 과정을 문으로 구현하고 코드 블럭으로 감싸서 하나의 실행 단위로 정의한 것.**
- 함수와 관련된 용어는 다음과 같다.
  - **매개변수**: 함수 내부로 입력을 전달받는 변수.
  - **인수**: 함수로 들어오는 입력.
  - **반환값**: 함수가 내보내는 출력.
- 함수는 값이며, 식별자로 특정 함수를 구분할 수 있다.
- 함수는 **함수 정의**로 생성한다.

```javascript
function add(x, y) {
  return x + y;
}
```

- 함수는 명시적으로 (인수와 함께) 호출해야 실행된다. 이를 **함수 호출**이라고 한다.

```javascript
console.log(add(1, 2)); // 3
```

## 12.2 함수를 사용하는 이유

1. 같은 동작을 하는 코드를 함수로 만들어 **재사용성** 증가.
2. 어떤 동작을 코드로 구현하는 데 실수가 있었을 때, 해당 함수만 수정하면 이 함수를 사용하는 모든 곳에 적용된다. 이는 **유지보수의 편의성**을 증가시킨다.
3. 같은 코드를 여러 번 쓰지 않으므로 실수가 줄어 **코드의 신뢰성**이 증가한다.
4. 어떤 동작을 하는 코드를 함수로 감싸고, 함수에 그 동작을 잘 설명할 수 있는 이름을 붙이면 함수명만으로 코드의 동작을 예상할 수 있어 **코드의 가독성**이 향상된다.

## 12.3 함수 리터럴

- 리터럴은 평가되어 값을 생성한다. 함수 리터럴도 값이 되어 변수에 할당될 수 있다.

```javascript
const sayHello = function (name) {
  console.log(`Hello, my name is ${name}!`);
};
```

- 함수 리터럴은 function 키워드, 함수명, 매개변수 목록, 함수 몸체로 구성된다.
  - 함수명
    - 식별자 네이밍 규칙을 지켜 지어야 한다.
    - 함수명은 함수 몸체 내에서만 참조할 수 있다.
    - 함수 이름은 생략할 수 있으며, 이름이 없는 함수를 **무명(익명) 함수**라고 한다.
  - 매개변수 목록
    - 각 매개변수에는 함수를 호출할 때 넘겨준 인수가 순서대로 할당된다. 즉, 매개변수 목록은 **순서를 가진다.**
    - 매개변수는 함수 몸체 안에서 변수와 같으므로 식별자 네이밍 규칙을 지켜 지어야 한다.
  - 함수 몸체
    - 함수가 호출될 때 실행할 문들을 하나의 실행 단위로 정의한 코드 블럭.
- 함수 리터럴은 값으로 평가되며 이 값은 **객체**다.
- 일반 객체와 함수가 다른 점은 다음과 같다.
  - 일반 객체와 다르게 함수는 호출할 수 있다.
  - 함수에는 일반 객체에 없는 고유한 프로퍼티가 있다.

## 12.4 함수 정의

- 자바스크립트에서 함수를 정의하는 방법에는 네 가지가 있다.
  1. 함수 선언문
  2. 함수 표현식
  3. `Funtion` 생성사 사용
  4. 화살표 함수

```javascript
// 함수 선언문
function sayHello(name) {
  console.log(name);
}

// 함수 표현식
const sayHello = function (name) {
  console.log(name);
};

// Function 생성자
const sayHello = new Function("name", "return console.log(name)");

// 화살표 함수
const sayHello = (name) => console.log(name);
```

### 12.4.1 함수 선언문

- 함수 선언문과 함수 리터럴은 형태가 동일하나, 함수 선언문에서는 함수 이름을 생략할 수 없다는 차이가 있다.
- 함수 선언문은 표현식이 아닌 문이다. 즉, 값으로 평가될 수 없다.
- 변수에는 오직 표현식만 할당할 수 있다. 그러나 함수 선언문은 _변수에 할당할 수 있는 것처럼 보인다._

```javascript
const sayHello = function sayHello(name) {
  console.log(name);
};
```

- 이는 함수 선언문이 변수에 할당된 것이 아니라, 자바스크립트 엔진이 함수 표현식으로 해석하여 변수에 할당한 것이다.
  - 이는 형태가 동일하나 코드 문맥에 따라 다양하게 해석될 수 있는 **중의적 표현**이다.
  - `{}`이 객체 리터럴로도, 코드 블럭으로도 해석될 수 있는 것과 같다.
- 한 가지 더 이상한 점은 자바스크립트에서 함수 선언문으로 함수를 선언하면 해당 함수를 함수명으로 호출할 수 있다는 것이다.

```javascript
function sayHello(name) {
  console.log(name);
}

sayHello("Choi"); // Choi
```

- 함수명은 함수 몸체 내부에서만 참조할 수 있다. 하지만 위의 코드에서는 함수명으로 함수 몸체 바깥에서 `sayHello` 함수를 호출하고 있다.
  - 이는 자바스크립트 엔진이 함수 선언문을 만나면 암묵적으로 함수명과 같은 이름의 식별자를 생성하기 때문이다.
  - 이러한 동작은 함수 표현식에서는 일어나지 않는다.

```javascript
/*
그룹 연산자를 사용하여 자바스크립트 엔진이 함수 선언문이 아닌 함수 표현식으로 해석하게 만들었다.
함수 표현식에서는 함수의 식별자가 암묵적으로 생성되지 않으므로 함수명으로 함수를 호출할 수 없다.
*/

(function sayHello(name) {
  console.log(name);
});

sayHello("Choi"); // Uncaught ReferenceError: sayHello is not defined
```

### 12.4.2 함수 표현식

- 자바스크립트에서 함수는 **객체 타입 값**이다.
- 이렇게 값으로 쓸 수 있는 객체를 **일급 객체**라고 한다.
- 함수는 값이기 때문에 변수에 할당할 수 있으며, 함수 리터럴을 통해 함수를 변수에 할당하는 정의 방식을 **함수 리터럴**이라고 한다.

```javascript
const sayHello = function (name) {
  console.log(name);
};

sayHello("Choi"); // Choi
```

- 위의 예시처럼 함수 리터럴에서는 함수명을 생략할 수 있으며, 이런 함수를 **익명 함수**라고 한다.

### 12.4.3 함수 호출 시점과 함수 호이스팅

- 함수 선언문에 대해서는 **함수 호이스팅**이 발생한다.
  - 즉, 런타임 이전에 함수 객체가 생성되고, 함수명과 동일한 이름의 식별자가 함수 객체로 초기화된다.
  - 따라서 함수 선언문을 쓰기 이전에 함수를 호출하는 것이 가능하다.
- 힘수 표현식에 대해서는 **변수 호이스팅**이 발생한다.
  - 즉, 런타임 이전에 함수 객체를 할당할 변수가 `undefined` 값으로 초기화된다.
  - 함수 객체는 할당문이 런타임에 실행되는 시점에 함수 리터럴이 평가되어 생성된다.
- 따라서 함수 선언문으로 선언한 함수는 선언문 이전에 호출할 수 있으나, 함수 표현식으로 생성한 함수는 할당문 이전에 호출할 수 없다.

```javascript
sayHello("Choi"); // Choi
add(1, 2); // 타입 에러(undefined는 호출될 수 없으므로)

const sayHello = function (name) {
  console.log(name);
};

const add = function (x, y) {
  return x + y;
};
```

- 함수 호이스팅이라는 함수 선언문의 특징 때문에 함수 선언문 대신 함수 표현식을 사용할 것을 권장하기도 한다.

### 12.4.4 Function 생성자 함수

- 일반적으로 생성자로 함수를 생성하는 방식은 권장되지 않는다.
- 생성자로 만든 함수는 클로저를 생성하지 않는다.

### 12.4.5 화살표 함수

- ES6에서 새로 만들어진 함수 선언 방식이다.
- 화살표 함수는 언제나 익명 함수이다.
- 화살표 함수가 함수 선언문이나 함수 표현식과 다른 점은 다음과 같다.
  1. 화살표 함수는 생성자 함수로 사용할 수 없다.
  2. 화살표 함수는 `this` 바인딩 방식이 다르다.
  3. 화살표 함수는 `prototype` 프로퍼티가 없다.
  4. 화살표 함수는 `argument` 객체를 생성하지 않는다.

```javascript
const sayHello = (name) => console.log(name);
```

## 12.5 함수 호출

- 함수는 함수 호출 연산자인 소괄호 `()` 안에 0개 이상의 인수를 쉼표로 구분하여 호출한다.
- 함수가 호출되면 현재 실행 흐름을 중지하고 호출된 함수로 실행 흐름을 옮긴다.

### 12.5.1 매개변수와 인수

- 함수가 호출될 때 함수 내부로 어떤 값을 전달해야 하는 경우 매개변수를 사용하여 인수를 함수 내부로 가져온다.
- 인수는 값으로 평가될 수 있는 표현식이어야 하며, 개수와 타입에 제한이 없다.
- 함수가 호출될 때 매개변수는 함수 몸체 안에서 암묵적으로 생성되고, `undefined` 값으로 초기화된다.
- 이후 전달받은 인수가 각 매개변수에 순서대로 할당된다.
- 매개변수는 오직 함수 몸체 내에서만 참조할 수 있다. 즉, 매개변수의 **스코프**는 함수 몸체 안이다.
- 함수는 매개변수의 개수와 전달받은 인수의 개수가 일치하는지를 검사하지 않는다. 즉, 인수는 정해진 매개변수보다 적을 가능성도, 많을 가능성도 있다.
  - 매개변수의 개수보다 인수의 개수가 적다면 인수를 받지 못한 매개변수의 값은 `undefined` 상태로 남게 된다.
  - 매개변수의 개수보다 인수의 개수가 많다면 초과된 인수는 무시된다.
  - 하지만 완전히 무시되는 것은 아니고, 모든 인수는 `arguments` 객체의 프로퍼티로 보관된다.
  - 이러한 특징은 매개변수의 개수를 함수를 정의하는 시점에서 확정할 수 없는 경우 **가변 인자 함수**를 만들 때 사용될 수 있다.

```javascript
function sayHello(name) {
  console.dir(arguments);
}

sayHello("Choi", "Kim", "Lee");
// [Arguments] { '0': 'Choi', '1': 'Kim', '2': 'Lee' }
```

### 12.5.2 인수 확인

- 자바스크립트 엔진은 함수에 전달되는 인수의 개수와 타입에 대해 어떠한 체크도 하지 않는다.
- 따라서 타입스크립트 등의 도구를 사용하지 않는다면 함수가 전달받는 인수의 개수와 타입에 대해 검사하는 코드를 작성하는 것이 도움이 된다.

```javascript
function add(x, y, z) {
  if (arguments.length !== 3) throw Error("인수의 개수가 잘못됐습니다.");
  if (typeof x !== "number" || typeof y !== "number" || typeof z !== "number")
    throw TypeError("인수 중 하나 이상이 number 타입이 아닙니다.");

  return x + y + z;
}

add(1, 2, 3, 4, 5); // 에러(인수의 개수가 잘못됐습니다.)
add('choi', 2, 3) // 에러(인수 중 하나 이상이 number 타입이 아닙니다.)

// ES6의 매개변수 기본값 할당을 사용하면 인수가 전달되지 않거나 undefined가 전달된 경우에 한해 런타임 에러를 방지할 수 있다.

function sayHello(name = 'unknown') {
  console.log(name);
}

sayHello(); // unknown
```
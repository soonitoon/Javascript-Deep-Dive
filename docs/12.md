# 12장: 함수

## 12.1 함수란?

- 프로그래밍 언어에서의 함수: **일련의 과정을 문으로 구현하고 코드 블럭으로 감싸서 하나의 실행 단위로 정의한 것.**
- 함수와 관련된 용어는 다음과 같다.
  - **매개변수**: 함수 내부로 입력을 전달받는 변수.
  - **인수**: 함수로 들어오는 입력.
  - **반환값**: 함수가 내보내는 출력.
- 함수는 값이며, 식별자로 특정 함수를 구분할 수 있다.
- 함수는 **함수 정의**로 생성한다.

```javascript
function add(x, y) {
  return x + y;
}
```

- 함수는 명시적으로 (인수와 함께) 호출해야 실행된다. 이를 **함수 호출**이라고 한다.

```javascript
console.log(add(1, 2)); // 3
```

## 12.2 함수를 사용하는 이유

1. 같은 동작을 하는 코드를 함수로 만들어 **재사용성** 증가.
2. 어떤 동작을 코드로 구현하는 데 실수가 있었을 때, 해당 함수만 수정하면 이 함수를 사용하는 모든 곳에 적용된다. 이는 **유지보수의 편의성**을 증가시킨다.
3. 같은 코드를 여러 번 쓰지 않으므로 실수가 줄어 **코드의 신뢰성**이 증가한다.
4. 어떤 동작을 하는 코드를 함수로 감싸고, 함수에 그 동작을 잘 설명할 수 있는 이름을 붙이면 함수명만으로 코드의 동작을 예상할 수 있어 **코드의 가독성**이 향상된다.

## 12.3 함수 리터럴

- 리터럴은 평가되어 값을 생성한다. 함수 리터럴도 값이 되어 변수에 할당될 수 있다.

```javascript
const sayHello = function (name) {
  console.log(`Hello, my name is ${name}!`);
};
```

- 함수 리터럴은 function 키워드, 함수명, 매개변수 목록, 함수 몸체로 구성된다.
  - 함수명
    - 식별자 네이밍 규칙을 지켜 지어야 한다.
    - 함수명은 함수 몸체 내에서만 참조할 수 있다.
    - 함수 이름은 생략할 수 있으며, 이름이 없는 함수를 **무명(익명) 함수**라고 한다.
  - 매개변수 목록
    - 각 매개변수에는 함수를 호출할 때 넘겨준 인수가 순서대로 할당된다. 즉, 매개변수 목록은 **순서를 가진다.**
    - 매개변수는 함수 몸체 안에서 변수와 같으므로 식별자 네이밍 규칙을 지켜 지어야 한다.
  - 함수 몸체
    - 함수가 호출될 때 실행할 문들을 하나의 실행 단위로 정의한 코드 블럭.
- 함수 리터럴은 값으로 평가되며 이 값은 **객체**다.
- 일반 객체와 함수가 다른 점은 다음과 같다.
  - 일반 객체와 다르게 함수는 호출할 수 있다.
  - 함수에는 일반 객체에 없는 고유한 프로퍼티가 있다.

## 12.4 함수 정의

- 자바스크립트에서 함수를 정의하는 방법에는 네 가지가 있다.
  1. 함수 선언문
  2. 함수 표현식
  3. `Funtion` 생성사 사용
  4. 화살표 함수

```javascript
// 함수 선언문
function sayHello(name) {
  console.log(name);
}

// 함수 표현식
const sayHello = function (name) {
  console.log(name);
};

// Function 생성자
const sayHello = new Function("name", "return console.log(name)");

// 화살표 함수
const sayHello = (name) => console.log(name);
```

### 12.4.1 함수 선언문

- 함수 선언문과 함수 리터럴은 형태가 동일하나, 함수 선언문에서는 함수 이름을 생략할 수 없다는 차이가 있다.
- 함수 선언문은 표현식이 아닌 문이다. 즉, 값으로 평가될 수 없다.
- 변수에는 오직 표현식만 할당할 수 있다. 그러나 함수 선언문은 _변수에 할당할 수 있는 것처럼 보인다._

```javascript
const sayHello = function sayHello(name) {
  console.log(name);
};
```

- 이는 함수 선언문이 변수에 할당된 것이 아니라, 자바스크립트 엔진이 함수 표현식으로 해석하여 변수에 할당한 것이다.
  - 이는 형태가 동일하나 코드 문맥에 따라 다양하게 해석될 수 있는 **중의적 표현**이다.
  - `{}`이 객체 리터럴로도, 코드 블럭으로도 해석될 수 있는 것과 같다.
- 한 가지 더 이상한 점은 자바스크립트에서 함수 선언문으로 함수를 선언하면 해당 함수를 함수명으로 호출할 수 있다는 것이다.

```javascript
function sayHello(name) {
  console.log(name);
}

sayHello("Choi"); // Choi
```

- 함수명은 함수 몸체 내부에서만 참조할 수 있다. 하지만 위의 코드에서는 함수명으로 함수 몸체 바깥에서 `sayHello` 함수를 호출하고 있다.
  - 이는 자바스크립트 엔진이 함수 선언문을 만나면 암묵적으로 함수명과 같은 이름의 식별자를 생성하기 때문이다.
  - 이러한 동작은 함수 표현식에서는 일어나지 않는다.

```javascript
/*
그룹 연산자를 사용하여 자바스크립트 엔진이 함수 선언문이 아닌 함수 표현식으로 해석하게 만들었다.
함수 표현식에서는 함수의 식별자가 암묵적으로 생성되지 않으므로 함수명으로 함수를 호출할 수 없다.
*/

(function sayHello(name) {
  console.log(name);
});

sayHello("Choi"); // Uncaught ReferenceError: sayHello is not defined
```

### 12.4.2 함수 표현식

- 자바스크립트에서 함수는 **객체 타입 값**이다.
- 이렇게 값으로 쓸 수 있는 객체를 **일급 객체**라고 한다.
- 함수는 값이기 때문에 변수에 할당할 수 있으며, 함수 리터럴을 통해 함수를 변수에 할당하는 정의 방식을 **함수 리터럴**이라고 한다.

```javascript
const sayHello = function (name) {
  console.log(name);
};

sayHello("Choi"); // Choi
```

- 위의 예시처럼 함수 리터럴에서는 함수명을 생략할 수 있으며, 이런 함수를 **익명 함수**라고 한다.

### 12.4.3 함수 호출 시점과 함수 호이스팅

- 함수 선언문에 대해서는 **함수 호이스팅**이 발생한다.
  - 즉, 런타임 이전에 함수 객체가 생성되고, 함수명과 동일한 이름의 식별자가 함수 객체로 초기화된다.
  - 따라서 함수 선언문을 쓰기 이전에 함수를 호출하는 것이 가능하다.
- 힘수 표현식에 대해서는 **변수 호이스팅**이 발생한다.
  - 즉, 런타임 이전에 함수 객체를 할당할 변수가 `undefined` 값으로 초기화된다.
  - 함수 객체는 할당문이 런타임에 실행되는 시점에 함수 리터럴이 평가되어 생성된다.
- 따라서 함수 선언문으로 선언한 함수는 선언문 이전에 호출할 수 있으나, 함수 표현식으로 생성한 함수는 할당문 이전에 호출할 수 없다.

```javascript
sayHello("Choi"); // Choi
add(1, 2); // 타입 에러(undefined는 호출될 수 없으므로)

const sayHello = function (name) {
  console.log(name);
};

const add = function (x, y) {
  return x + y;
};
```

- 함수 호이스팅이라는 함수 선언문의 특징 때문에 함수 선언문 대신 함수 표현식을 사용할 것을 권장하기도 한다.

### 12.4.4 Function 생성자 함수

- 일반적으로 생성자로 함수를 생성하는 방식은 권장되지 않는다.
- 생성자로 만든 함수는 클로저를 생성하지 않는다.

### 12.4.5 화살표 함수

- ES6에서 새로 만들어진 함수 선언 방식이다.
- 화살표 함수는 언제나 익명 함수이다.
- 화살표 함수가 함수 선언문이나 함수 표현식과 다른 점은 다음과 같다.
  1. 화살표 함수는 생성자 함수로 사용할 수 없다.
  2. 화살표 함수는 `this` 바인딩 방식이 다르다.
  3. 화살표 함수는 `prototype` 프로퍼티가 없다.
  4. 화살표 함수는 `argument` 객체를 생성하지 않는다.

```javascript
const sayHello = (name) => console.log(name);
```

## 12.5 함수 호출

- 함수는 함수 호출 연산자인 소괄호 `()` 안에 0개 이상의 인수를 쉼표로 구분하여 호출한다.
- 함수가 호출되면 현재 실행 흐름을 중지하고 호출된 함수로 실행 흐름을 옮긴다.

### 12.5.1 매개변수와 인수

- 함수가 호출될 때 함수 내부로 어떤 값을 전달해야 하는 경우 매개변수를 사용하여 인수를 함수 내부로 가져온다.
- 인수는 값으로 평가될 수 있는 표현식이어야 하며, 개수와 타입에 제한이 없다.
- 함수가 호출될 때 매개변수는 함수 몸체 안에서 암묵적으로 생성되고, `undefined` 값으로 초기화된다.
- 이후 전달받은 인수가 각 매개변수에 순서대로 할당된다.
- 매개변수는 오직 함수 몸체 내에서만 참조할 수 있다. 즉, 매개변수의 **스코프**는 함수 몸체 안이다.
- 함수는 매개변수의 개수와 전달받은 인수의 개수가 일치하는지를 검사하지 않는다. 즉, 인수는 정해진 매개변수보다 적을 가능성도, 많을 가능성도 있다.
  - 매개변수의 개수보다 인수의 개수가 적다면 인수를 받지 못한 매개변수의 값은 `undefined` 상태로 남게 된다.
  - 매개변수의 개수보다 인수의 개수가 많다면 초과된 인수는 무시된다.
  - 하지만 완전히 무시되는 것은 아니고, 모든 인수는 `arguments` 객체의 프로퍼티로 보관된다.
  - 이러한 특징은 매개변수의 개수를 함수를 정의하는 시점에서 확정할 수 없는 경우 **가변 인자 함수**를 만들 때 사용될 수 있다.

```javascript
function sayHello(name) {
  console.dir(arguments);
}

sayHello("Choi", "Kim", "Lee");
// [Arguments] { '0': 'Choi', '1': 'Kim', '2': 'Lee' }
```

### 12.5.2 인수 확인

- 자바스크립트 엔진은 함수에 전달되는 인수의 개수와 타입에 대해 어떠한 체크도 하지 않는다.
- 따라서 타입스크립트 등의 도구를 사용하지 않는다면 함수가 전달받는 인수의 개수와 타입에 대해 검사하는 코드를 작성하는 것이 도움이 된다.

```javascript
function add(x, y, z) {
  if (arguments.length !== 3) throw Error("인수의 개수가 잘못됐습니다.");
  if (typeof x !== "number" || typeof y !== "number" || typeof z !== "number")
    throw TypeError("인수 중 하나 이상이 number 타입이 아닙니다.");

  return x + y + z;
}

add(1, 2, 3, 4, 5); // 에러(인수의 개수가 잘못됐습니다.)
add("choi", 2, 3); // 에러(인수 중 하나 이상이 number 타입이 아닙니다.)

// ES6의 매개변수 기본값 할당을 사용하면 인수가 전달되지 않거나 undefined가 전달된 경우에 한해 런타임 에러를 방지할 수 있다.

function sayHello(name = "unknown") {
  console.log(name);
}

sayHello(); // unknown
```

### 12.5.3 매개변수의 최대 개수

- ECMAScript에서는 함수의 매개변수 개수에 제한을 명시하고 있지 않다(물론 자바스크립트 엔진마다 내부적으로 제한을 두고 있을 것이다.).
- 매개변수의 개수는 **적을수록 좋다.**
  - 함수는 한 가지 일만 수행해야 하며 작을수록 좋다.
  - 매개변수의 개수가 많다는 것은 하나의 함수가 여러 일을 처리한다는 증거이기도 하다.
  - 또한, (타입스크립트 등의 도구를 쓰지 않는다는 가정 하에) 인수를 전달할 때는 오직 전달하는 순서로만 매개변수에 할당되기 때문에 함수를 사용할 때 실수가 발생할 가능성 역시 커진다.
- 피치 못하게 여러 매개변수가 필요한 경우에는 필요한 변수들을 하나의 객체로 전달받는 것이 좋다.
  - 각 값들이 객체의 프로퍼티 이름으로 구분되기 때문에 순서에 의존하는 것보다 실수의 가능성을 줄이며, 프로퍼티 이름이 필요한 값에 대해 설명해주기 때문이다.
  - 하지만 객체를 인수로 전달받을 경우, 함수 내부에서 객체를 수정하게 되면 함수 외부의 객체가 같이 수정되는 문제가 발생한다.

```javascript
// 필요한 인수를 여러 개의 매개변수로 받는 함수
function introduce(name, gender, address, job) {
  console.log(`
    name: ${name}
    gender: ${gender}
    address: ${address}
    job: ${job}
  `);
}

// 인수 여러 개를 전달하는 과정에서 실수할 가능성이 높음. ❌
introduce("Choi", "male", "Korea...", "student");

// 필요한 인수를 profile이란 객체로 묶어 전달받는 함수
function introduce2(profile) {
  const { name, gender, address, job } = profile;
  console.log(`
    name: ${name}
    gender: ${gender}
    address: ${address}
    job: ${job}
  `);
}

const Choi = {
  name: "Choi",
  gender: "male",
  address: "Korea...",
  job: "student",
};

// 객체의 프로퍼티 이름으로 필요한 인수를 구분할 수 있어 전달 순서에만 의존하는 것보다 안전함. ✅
introduce2(Choi);
```

### 12.5.4 반환문

- 반환문은 `return` 키워드와 그 뒤에 오는 표현식으로 이루어진다.
- 또한, 함수 호출문은 그 함수의 반환값으로 평가된다. 즉, **함수 호출은 표현식이다**.
- 함수 실행 도중에 반환문을 만나면 반환문 밑의 코드는 무시되고 함수가 종료된다.
- `return` 키워드 뒤에 표현식을 생락하거나 반환문 자체를 생략하면 해당 함수는 암묵적으로 `undefined` 값을 반환한다.
- `return` 키워드와 반환할 표현식 사이에 줄바꿈을 하면 안 된다. `return` 키워드 뒤에 세미콜론이 자동으로 삽입되어 `undefined`가 반환되기 때문이다.

```javascript
function add(x, y) {
  return;
  x + y;
}

add(1, 1); // undefined
```

- `return` 키워드는 함수 몸체 내부에서만 사용할 수 있으며, 외부에서 사용할 경우 문법 에러가 발생한다.
  - 다만 Node.js 환경에서는 파일별로 **파일 스코프**를 갖기 때문에 함수 몸체 외부에서 `return` 키워드를 사용해도 에러가 발생하지 않는다.

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 매개변수도 일반 변수와 마찬가지로 **값에 의한 전달**과 **참조에 의한 전달** 방식을 따른다.
- 원시값은 값에 의한 전달을 따르므로 함수에 인자로 전달한 후에 해당 값이 담긴 매개변수를 수정해도 원본값에 영향을 받지 않는다.
- 객체는 참조에 의한 전달을 따르므로 함수에 매개변수로 전달한 객체를 수정하면 원본 객체도 같이 수정된다.

```javascript
const choi = {
  name: "Choi",
  gender: "male",
};

const x = 1;

function changer(number, object) {
  number += 1;
  object.gender = "female";
}

changer(x, choi);

console.log(x, choi); // 1 { name: 'Choi', gender: 'female' }
```

- 함수의 내부 동작에 의해 함수 외부의 객체를 수정하는 것은 좋지 않은 방법이다.
  - 어떤 객체가 함수 동작에 의해 언제든지 수정될 수 있다는 사실은 해당 객체의 **상태 변화를 추적하기 어렵게 만들고**, **유지보수성을 떨어뜨린다.**
- 따라서 객체를 함수 내부에서 수정하는 경우에는 해당 객체의 **깊은 복사본**을 만들어 해당 복사본을 수정하는 것이 바람직하다. 이를 **방어적 복사**라고 한다.
- 이렇게 외부 상태를 변경하지 않고, 외부 상태에 의존하지도 않는 함수를 **순수 함수**라고 한다.

## 12.7 다양한 함수 형태

### 12.7.1 즉시 실행 함수

- 함수 정의와 동시에 호출되는 함수를 **즉시 실행 함수**라고 한다.
- 즉시 실행 함수는 다시 호출할 수 없다.
- 즉시 실행 함수는 익명 함수로 정의하는 것이 일반적이다.

```javascript
(function () {
  console.log("hello");
})();

// 즉시 실행 함수도 인수를 전달받을 수 있다.
(function (name) {
  console.log(`Hello, ${name}!`);
})("Choi");

// 함수 호출 연산자를 그룹 연산자 밖에서 쓸 수도 있다.

(function () {
  console.log("hello");
})();
```

- 즉시 실행 함수는 기명 함수로도 만들 수 있다. 하지만 변수에 할당한 것은 아니므로 함수명으로 호출할 수는 없다.

```javascript
(function sayHello() {
  console.log("hello");
})();

sayHello(); // Uncaught ReferenceError: sayHello is not defined
```

- 즉시 실행 함수는 함수 선언문이 아닌 함수 표현식으로 해석되어야 한다. 따라서 자바스크립트 엔진이 표현식으로 해석할 수 있게끔 그룹 연산자 `()`로 문맥을 제공했다.
  - 표현식으로 해석될 수 있는 다른 방법을 사용할 수도 있다.

```javascript
!(function () {
  console.log("hello");
})();

+(function () {
  console.log("hello");
})();
```

- 즉시 실행 함수로 코드를 감싸놓으면 변수명이나 함수명의 충돌을 방지할 수 있다.

### 12.7.2 재귀 함수

- 함수 내부에서 자기 자신을 호출하는 함수를 **재귀 함수**라고 한다.
- 재귀 함수는 자기 자신을 무한 호출하므로 반드시 함수 내부에 재귀 탈출 조건을 만들어야 한다.
- 팩토리얼 계산 등과 같이 재귀 호출이 직관적일 때만 사용하는 것이 바람직하며, 그렇지 않을 때는 일반 반복문으로 반복 처리를 구현하는 게 더 낫다.

```javascript
// 재귀함수로 구현한 팩토리얼
function factorial1(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

// 반복문으로 구현한 팩토리얼
function factorial2(n) {
  let result = 1;
  for (let i = 1; i <= n; i++) result *= i;
  return result;
}
```

### 12.7.3 중첩 함수

- 어떤 함수 내부에 정의된 함수를 **중첩 함수**, **내부 함수**라고 한다.
- 중첩 함수를 포함하는 바깥 함수를 **외부 함수**라고 한다.
- 일반적으로 중첩 함수는 외부 함수의 처리를 돕는 **헬퍼 함수**의 역할을 한다.

```javascript
function printAllGugu() {
  function printGugu(n) {
    for (let i = 1; i < 10; i++) console.log(`${n} * ${i} = ${n * i}`);
  }
  
  for (let i = 2; i < 10; i++) printGugu(i);
}
```

- ES6 이전에 함수 선언문은 코드 최상위나 다른 함수 내부에서만 사용할 수 있었지만, ES6 이후부터는 코드 블럭 내에서도 정의할 수 있게 되었다.
  - 하지만 if문이나 for문 등의 다른 코드 블럭 내에서 함수를 정의하는 방법은 일반적으로 권장되지 않는다.

### 12.7.4 콜백 함수

- 다른 함수에 매개변수로 전달되는 함수를 **콜백 함수**라고 한다.
- 콜백 함수를 전달받는 함수를 **고차 함수**라고 한다.
- 콜백 함수가 존재하는 이유는 어떤 함수가 비슷하지만 다양한 일을 처리해야 할 때 매번 새롭게 함수를 정의하지 않고, 바뀌는 부분의 처리만 추상화하여 외부에서 전달받기 위해서이다.
- 콜백 함수 역시 다른 함수와 마찬가지로 인수를 전달받을 수 있다.

```javascript
function repeatWhenOdd(n, f) {
  for (let i = 1; i <= n; i++) {
    if (i % 2 !== 0) f();
  }
}

function printHello() {
  console.log("Hello!");
}

function printGoodbye() {
  console.log("Goodbye");
}

repeatWhenOdd(10, printHello); // 1부터 10까지 홀수일 때만 Hello가 출력된다.
repeatWhenOdd(10, printGoodbye); // 1부터 10까지 홀수일 때만 Goodbye가 출력된다.
```

- 콜백 함수는 고차 함수를 호출할 때 리터럴로 매개변수에 바로 할당하는 것이 일반적인 사용법이다.
  - 고차 함수 안에서 실행될 동작을 리터럴로 표현해놓는 것이 코드 흐름을 읽는 데에 도움이 되기 때문이다.
  - 하지만 고차 함수의 호출 연산자 안에 리터럴로 정의된 콜백 함수는 고차 함수가 호출될 때마다 값으로 평가된다.
  - 따라서 고차 함수가 자주 호출되는 함수이거나 똑같은 콜백 함수를 다른 고차 함수에서도 사용한다면 식별자를 가진 함수로 따로 빼는 것이 효율적이다.

```javascript
repeatWhenOdd(10, () => console.log("Goodbye"));
```

- 이러한 고차 함수와 콜백 함수 구조는 자바스크립트의 배열 메소드에서 매우 유용하게 사용된다.

```javascript
const arr = [1, 2, 3, 4];

const newArr = arr.map(num => num * 2);

console.log(newArr) // [2, 4, 6, 8]
// 배열 메소드인 map은 콜백 함수를 인자로 받는데, 배열 안 모든 요소를 콜백 함수가 반환하는 값으로 변경한 결과인 새로운 배열을 반환한다.
// 여기서 콜백 함수는 배열의 모든 요소에 대해 2를 곱한 값을 반환한다. 
```

### 12.7.5 순수 함수와 비순수 함수

- **순수 함수**는 동일한 인수를 전달받았을 때 언제나 동일한 값을 반환하는 함수이다.
  - 다른 말로 하면, 순수 함수는 외부 상태에 의존하지도 않고 외부 상태를 변경하지도 않는 함수이다.
  - 일반적으로 하나 이상의 인수를 전달 받는 함수에 해당한다. 인수를 받지 않는 함수는 상수와 다를 바 없기 때문이다.
  - 또한 순수 함수는 **인수의 불변성**을 유지한다. 즉, 인수를 변경하지 않는다.
- **비순수 함수**는 외부 상태에 의존하거나 외부 상태를 변경하는 함수를 말한다.
  - 외부 상태를 변경한다는 말은 **부수 효과**가 있다는 말이다.
  - 함수 내부에서 매개변수로 전달받은 객체를 직접 수정한다면 비순수 함수가 된다.

```javascript
// 순수 함수로 구현한 increase 함수
function increase(n) {
  return n + 1;
}

let count = 0;
count = increase(count);

// 매개변수 n으로 전달받는 인수가 똑같다면 반환값도 언제나 같다.

// 비순수 함수로 구현한 increase 함수
function increase2() {
  count += 1;
}

increase2();
// 함수가 전역 변수 count에 의존한다.
```

- 비순수 함수 대신 순수 함수를 작성하는 것이 좋다. 비순수 함수가 가진 단점 때문이다.
  - 비순수 함수의 존재는 전역 상태가 비순수 함수에 의해 바뀔 수 있음을 암시한다. 이는 코드의 복잡성을 증가시킨다.
  - 비순수 함수는 전역 상태가 바뀌는 과정을 추적하기 어렵게 만든다. 따라서 디버깅이 어려워진다.
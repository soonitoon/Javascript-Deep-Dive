# 11장: 원시 값과 객체의 비교

- 자바스크립트의 값은 크게 **원시 타입**과 **객체 타입**으로 나뉘고, 이 둘은 세 가지 측면에서 다르다.
  1. 원시 타입 값은 변경 불가능한 값이고, 객체 타입 값은 변경 가능한 값이다.
  2. 원시 값을 변수에 할당하면 실제 값이 저장된다. 객체 값을 변수에 할당하면 참조 값이 저장된다.
  3. 원시 값이 할당된 변수를 다른 변수에 할당하면 실제 값이 복사되어 전달된다(**값에 의한 전달**). 객체 값이 할당된 변수를 다른 변수에 할당하면 참조 값이 복사되어 전달된다(**참조에 의한 전달**).

## 11.1 원시 값

### 11.1.1 변결 불가능한 값

- 원시 타입의 값은 변경 불가능한 값이다. 즉, **읽기 전용**이다.
- 여기서 변경 불가능한 것은 원시 값 자체이지 원시 값이 할당된 변수가 아니다.
- `const` 키워드를 사용하여 상수로 선언하지 않은 이상 변수에는 어떤 값도 다시 재할당할 수 있다.
- `const` 키워드로 선언한 상수 역시 **재할당이 금지된 변수**일 뿐이며 원시 값의 변경 불가능성을 의미하는 것은 아니다.
- 원시 값이 변경 불가능하기 때문에 새로운 원시 값을 재할당 할 때 기존 메모리 주소에 저장된 값을 바꿀 수 없다.
- 따라서 새로운 메모리 공간을 확보하고 재할당할 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경하는 방식으로 재할당이 이루어진다.
- 이러한 원시 값의 특성을 **불변성**이라고 하며, 데이터의 신뢰성을 보장한다.

### 11.1.2 문자열과 불변성

- 숫자 타입의 값과는 다르게 문자열은 문자열의 길이에 따라 필요한 메모리 공간의 크기가 달라진다.
- 따라서 C에서는 하나의 문자를 위한 데이터 타입 `char`만 존재하며, Java에서는 문자열을 `String` 객체로 처리한다.
- 자바스크립트는 문자열을 위한 원시 타입을 제공한다. 원시 타입이므로 변경 불가능하다.
- 문자열은 **유사 배열 객체**이다.
  - 유사 배열 객체란 인덱스로 프로퍼티 값에 접근할 수 있고, `length` 프로퍼티를 갖는 객체를 말한다.
  - 문자열의 프로퍼티에 접근하면 원시 타입 문자열은 래퍼 객체로 자동 변환된다.

```js
var str = 'string';

console.log(str[0]); // s
console.log(str.length)l // 6

str[0] = 'R';
console.log(str); // 'string'
// 문자열은 원시 타입 값이므로 변경할 수 없다.
// 위의 표현식은 에러 없이 무시된다.
```

### 11.1.3 값에 의한 전달

- "변수에 변수를 할당하면 무엇이 전달되는가?"
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달된다.
- 이를 **값에 의한 전달**이라고 한다.
- 따라서 두 변수는 서로 다른 메모리 공간을 참조하게 되며, 서로의 값을 변경할 수 없다.

```js
var original = 20;
var copy = original;
copy = 30;

console.log(original); // 20
console.log(copy); // 30
```

- 원시 값이 저장된 변수를 다른 변수에 할당할 때 두 가지 평가 방식이 있다.
  - 기존 원시 값을 복사해서 새로운 메모리 공간에 저장하는 방식.
    - 할당 시점부터 두 변수가 참조하는 메모리 공간이 다르다.
  - 기존 원시 값이 저장된 메모리 공간을 그대로 전달하는 방식.
    - 할당 시점에는 두 변수가 참조하는 메모리 공간이 같다.
    - 어떤 변수에 다른 값을 할당하는 순간 두 변수가 각각 참조하는 메모리 공간이 달라진다.
    - ex) 파이썬
  - 두 방법 모두 두 변수가 서로를 간섭할 수 없다.

## 11.2 객체

- 객체는 프로퍼티의 개수가 정해져 있지 않다.
- 프로퍼티는 동적으로 추가되거나 삭제될 수 있다.
- 프로퍼티의 값에는 제약이 없다.
- 따라서 객체는 원시 값에 비해 상대적으로 많은 메모리 공간을 차지하며, 프로퍼티의 값에 접근하는 작업에도 비용이 든다.

### 11.2.1 변경 가능한 값

- 객체는 **변경 가능한 값**이다.
  - 원시 값을 할당한 변수의 메모리 공간에는 원시 값 자체가 저장됨.
  - 객체를 할당한 변수는의 메모리 공간에는 **참조 값**이 저장된다.
    - 참조값: 객체가 저장된 메모리 공간의 주소.
  - 원시 값의 경우 `"변수는 ~ 값을 갖는다."`, `"변수의 값은 ~ 다."`라고 표현함.
  - 객체의 경우 `"변수는 ~ 객체를 참조한다."`, `"변수는 ~ 객체를 가리키고 있다."`라고 표현함.

```js
// 객체는 프로퍼티를 추가, 변경, 삭제할 수 있음.

const person = {};

person.name = "Choi";
person.age = 24;

console.log(person); // { name: 'Choi', age: 24 }

delete person.age;

console.log(person); // { name: 'Choi' }
```

```js
// 변수는 객체 자체가 아니라 객체의 참조 값을 저장한다.

const person = {
  name: "Choi",
};
const person2 = person; // person2와 person은 같은 객체를 참조하게 된다.
person.name = "Kim";

console.log(person); // { name: 'Kim' }
console.log(person2); // { name: 'Kim' }
```

- 이러한 객체의 특성 때문에 객체에는 **얕은 복사**와 **깊은 복사**라는 개념이 있다.
  - 얕은 복사: 객체의 참조 값만 다른 변수에 저장하는 것.
  - 깊은 복사: 객체를 똑같이 복사하여 원본과 다른 복사본을 만드는 것.

```js
const person = {
  name: "Choi",
  age: 24,
};
const person2 = person; // 얕은 복사. 둘은 하나의 객체를 참조함.

person.name = "Kim";

console.log(person); // { name: 'Kim', age: 24 }
console.log(person2); // { name: 'Kim', age: 24}
```

```js
const person = {
  name: "Choi",
  age: 24,
};

const person2 = {};

Object.entries(person).forEach(([key, value]) => {
  person2[key] = value;
});

// 깊은 복사. person의 모든 key와 key에 해당하는 value를 person2에 똑같은 쌍으로 복사함.

person.name = "Kim";

console.log(person); // { name: 'Kim', age: 24}
console.log(person2); // { name: 'Choi', age: 24 }
```

### 11.2.2 참조에 의한 전달

- 흔히 자바스크립트에서 변수에 변수를 할당하는 경우를 두 가지로 설명한다.
  1. 원시값이 할당된 변수를 다른 변수에 할당하는 경우 -> 값에 의한 전달.
  2. 객체(의 참조 값)가 할당된 변수를 다른 변수에 할당하는 경우 -> 참조에 의한 전달.
- 하지만 2번의 경우 역시 참조 **값**을 전달한다는 점에 있어 값에 의한 전달이라고 볼 수 있다.
- 즉, 엄밀한 의미에서 자바스크립트에는 **값에 의한 전달 방식 밖에 존재하지 않는다.**

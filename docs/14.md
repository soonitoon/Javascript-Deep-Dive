# 14장: 전역 변수의 문제점

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

- 모든 변수는 **생명 주기**를 갖는다.
- 변수는 선언된 위치에서 생성되고 선언된 위치에서 소멸한다.
  - 따라서 전역 변수의 생명 주기는 어플리케이션 전체의 생명 주기와 같다.
  - 함수 내부의 지역 변수는 함수가 호출될 때 생성되고 함수가 종료될 때 소멸한다. 즉, 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.
- 이는 호이스팅 동작에서도 마찬가지이다.
  - 전역 변수의 선언문은 런타임 이전에 실행되어 `undefined`로 초기화된다.
  - 함수 내부의 지역 변수 선언문은 함수가 호출된 이후 몸체의 코드가 실행되기 전에 실행되어 `undefined`로 초기화된다.
- 하지만 지역 변수의 생명 주기가 함수의 생명 주기와 일치하지 않는 경우도 있다.
  - 누군가가 해당 함수의 클로저를 참조하고 있는 경우이다.
  - 즉, 해당 함수의 스코프는 함수가 종료되어도 여전히 남아있는 것이다.
  - 이후 스코프나 변수를 누구도 참조하지 않게 되면 가비지 컬렉터에 의해 수집되어 가용 메모리 풀에 반환된다. 이것이 생명 주기의 종료이다.

### 14.1.2 전역 변수의 생명 주기

- 자바스크립트 엔진은 코드 실행 이전에 **전역 객체**를 먼저 생성한다.
  - 전역 객체는 브라우저 환경에서 `window`, Node 환경에서는 `global`로 참조할 수 있다.
- `var` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다.
- 즉, `var` 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 같다.

## 14.2 전역 변수의 문제점

1. **암묵적 결합**
   - 전역 변수는 코드의 모든 범위에서 수정하고 참조할 수 있는 **암묵적 결합**을 허용한다.
2. **긴 생명 주기**
   - 변수의 생명 주기가 길다는 것은 해당 변수를 변경할 수 있는 가능성이 높다는 의미이다.
   - 또한 생명 주기가 긴 만큼 메모리 공간을 소비하는 기간도 길다.
   - `var` 키워드로 선언한 변수의 경우 재선언이 가능하므로 변수의 생명 주기가 길수록 재선언될 가능성도 높아진다.
3. **스코프 체인의 마지막에 존재**
   - 전역 변수는 스코프 체인에서 언제나 마지막에 검색되므로 검색 속도가 가장 느리다.
4. **네임스페이스 오염**
   - 자바스크립트는 파일로 분리되어 있어도 하나의 네임스페이스를 공유하는 특성이 있다.
   - 따라서 각기 다른 파일에 동일한 이름을 가진 전역 변수나 함수가 있을 경우 문제를 일으킬 수 있다.

## 14.3 전역 변수의 사용을 억제하는 방법

- 위의 이유로 변수의 스코프는 좁을수록 좋다.
- 전역 변수의 사용이 불가피할 때는 전역 변수를 대체할 수 있는 다른 방법을 사용하는 것을 고려할 수 있다.

### 14.3.1 즉시 실행 함수

- 전역에서 실행해야 할 코드와 변수를 즉시 실행 함수의 스코프 안에 묶는 방법.
- 함수의 스코프 소멸과 동시에 변수도 소멸한다.

```javascript
(function () {
  var name = "Choi";
  console.log(name);
})();
```

### 14.3.2 네임스페이스 객체

- 전역으로 사용할 변수를 네임스페이스 역할을 하는 객체 안에 넣어 사용하는 방법.
- 네임스페이스의 충돌은 방지할 수 있겠지만, 결국 네임스페이스 객체 역시 전역 변수라는 점은 피할 수 없다.

```javascript
var PERSON = {};
PERSON.choi = "Choi";
PERSON.kim = "Kim";

console.log(PERSON.choi);
console.log(PERSON.kim);
```

### 14.3.3 모듈 패턴

- 즉시 실행 함수로 클래스 형태를 모방하여 캡슐화를 구현하는 방법.
  - 즉시 실행 함수의 몸체에 프로퍼티 역할을 하는 변수와 메소드 역할을 하는 중첩 함수를 만든다.
  - 이후 즉시 실행 함수가 전역에서 사용할 프로퍼티를 반환하도록 한다.
  - 즉시 실행 함수의 스코프가 종료되면 프로퍼티 역할을 하는 변수는 외부에서 참조할 수 없다.
  - 오직 반환받은 함수를 통해서만 해당 변수를 사용할 수 있게 된다.

```javascript
var HelloTools = (
  function() {
    var choi = 'Choi';
    var kim = 'Kim';

    return {
      helloChoi() {
        console.log(choi);
      },
      helloKim() {
        console.log(kim);
      }
    }
  }()
);

HelloTools.helloChoi(); // Choi
HelloTools.helloKim(); // Kim

console.log(choi); // Uncaught ReferenceError: choi is not defined
console.log(kim); // Uncaught ReferenceError: kim is not defined

/*
즉시 실행 함수로 구현한 모듈 패턴.
변수 choi와 kim은 외부에서 접근하거나 수정할 수 없다.
오직 helloChoi와 helloKim 함수를 통해서만 제한적으로 사용할 수 있는 변수가 만들어졌다.
*/
```

### 14.3.4 ES6 모듈

- ES6의 모듈을 도입하면 전역 변수라는 개념 자체가 사라지게 된다.
- ES6 모듈은 각각의 파일이 모듈 스코프를 갖게 만들기 때문이다.
- 따라서 모듈 내부에서 코드 최상위에 선언한 변수는 전역 변수가 아니라 모듈 스코프 내부의 변수가 된다.
- 모듈을 사용하기 위해서는 HTML의 `script` 태그에 `type=module` 속성을 추가하면 된다(스크립트 파일의 확장자는 `.js`가 아니라 `.mjs`를 사용하여 모듈로서 동작한다는 것을 명시하는 것이 좋다.).

```html
<script type="module" src="index.mjs"></script>
```